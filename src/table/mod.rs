/*
Table:

Table is consist of one or more data blocks, an optional filter block
a metaindex block, an index block and a table footer. Metaindex block
is a special block used to keep parameters of the table, such as filter
block name and its block handle. Index block is a special block used to
keep record of data blocks offset and length, index block use one as
restart interval. The key used by index block are the last key of preceding
block, shorter separator of adjacent blocks or shorter successor of the
last key of the last block. Filter block is an optional block contains
sequence of filter data generated by a filter generator.

Table data structure:
                                                         + optional
                                                        /
    +--------------+--------------+--------------+------+-------+-----------------+-------------+--------+
    | data block 1 |      ...     | data block n | filter block | metaindex block | index block | footer |
    +--------------+--------------+--------------+--------------+-----------------+-------------+--------+

    Each block followed by a 5-bytes trailer contains compression type and checksum.

Table block trailer:

    +---------------------------+-------------------+
    | compression type (1-byte) | checksum (4-byte) |
    +---------------------------+-------------------+

    The checksum is a CRC-32 computed using Castagnoli's polynomial. Compression
    type also included in the checksum.

Table footer:

      +------------------- 40-bytes -------------------+
     /                                                  \
    +------------------------+--------------------+------+-----------------+
    | metaindex block handle / index block handle / ---- | magic (8-bytes) |
    +------------------------+--------------------+------+-----------------+

    The magic are first 64-bit of SHA-1 sum of "http://code.google.com/p/leveldb/".

NOTE: All fixed-length integer are little-endian.
*/

/*
Block:

Block is consist of one or more key/value entries and a block trailer.
Block entry shares key prefix with its preceding key until a restart
point reached. A block should contains at least one restart point.
First restart point are always zero.

Block data structure:

      + restart point                 + restart point (depends on restart interval)
     /                               /
    +---------------+---------------+---------------+---------------+---------+
    | block entry 1 | block entry 2 |      ...      | block entry n | trailer |
    +---------------+---------------+---------------+---------------+---------+

Key/value entry:

              +---- key len ----+
             /                   \
    +-------+---------+-----------+---------+--------------------+--------------+----------------+
    | shared (varint) | not shared (varint) | value len (varint) | key (varlen) | value (varlen) |
    +-----------------+---------------------+--------------------+--------------+----------------+

    Block entry shares key prefix with its preceding key:
    Conditions:
        restart_interval=2
        entry one  : key=deck,value=v1
        entry two  : key=dock,value=v2
        entry three: key=duck,value=v3
    The entries will be encoded as follow:

      + restart point (offset=0)                                                 + restart point (offset=16)
     /                                                                          /
    +-----+-----+-----+----------+--------+-----+-----+-----+---------+--------+-----+-----+-----+----------+--------+
    |  0  |  4  |  2  |  "deck"  |  "v1"  |  1  |  3  |  2  |  "ock"  |  "v2"  |  0  |  4  |  2  |  "duck"  |  "v3"  |
    +-----+-----+-----+----------+--------+-----+-----+-----+---------+--------+-----+-----+-----+----------+--------+
     \                                   / \                                  / \                                   /
      +----------- entry one -----------+   +----------- entry two ----------+   +---------- entry three ----------+

    The block trailer will contains two restart points:

    +------------+-----------+--------+
    |     0      |    16     |   2    |
    +------------+-----------+---+----+
     \                      /     \
      +-- restart points --+       + restart points length

Block trailer:

      +-- 4-bytes --+
     /               \
    +-----------------+-----------------+-----------------+------------------------------+
    | restart point 1 |       ....      | restart point n | restart points len (4-bytes) |
    +-----------------+-----------------+-----------------+------------------------------+


NOTE: All fixed-length integer are little-endian.
*/

/*
Filter block:

Filter block consist of one or more filter data and a filter block trailer.
The trailer contains filter data offsets, a trailer offset and a 1-byte base Lg.

Filter block data structure:

      + offset 1      + offset 2      + offset n      + trailer offset
     /               /               /               /
    +---------------+---------------+---------------+---------+
    | filter data 1 |      ...      | filter data n | trailer |
    +---------------+---------------+---------------+---------+

Filter block trailer:

      +- 4-bytes -+
     /             \
    +---------------+---------------+---------------+-------------------------------+------------------+
    | data 1 offset |      ....     | data n offset | data-offsets offset (4-bytes) | base Lg (1-byte) |
    +-------------- +---------------+---------------+-------------------------------+------------------+


NOTE: All fixed-length integer are little-endian.
*/

// from google/leveldb
//
// When we store a key, we drop the prefix shared with the previous
// string.  This helps reduce the space requirement significantly.
// Furthermore, once every K keys, we do not apply the prefix
// compression and store the entire key.  We call this a "restart
// point".  The tail end of the block stores the offsets of all of the
// restart points, and can be used to do a binary search when looking
// for a particular key.  Values are stored as-is (without compression)
// immediately following the corresponding key.
//
// An entry for a particular key-value pair has the form:
//     shared_bytes: varint32
//     unshared_bytes: varint32
//     value_length: varint32
//     key_delta: char[unshared_bytes]
//     value: char[value_length]
// shared_bytes == 0 for restart points.
//
// The trailer of the block has the form:
//     restarts: uint32[num_restarts]
//     num_restarts: uint32
// restarts[i] contains the offset within the block of the ith restart point.

use crate::api;

mod block;
mod table;

// 1-byte type + 32-bit crc
const BLOCK_TRAILER_SIZE: usize = 5;

// The block type gives the per-block compression format.
// These constants are part of the file format and should not be changed.
const BLOCK_TYPE_NO_COMPRESSION: u8 = 0;
const BLOCK_TYPE_SNAPPY_COMPRESSION: u8 = 1;

const KiB: usize = 1024;
const DEFAULT_BLOCK_SIZE: usize = 4 * KiB;

// Encoded length of a Footer.  Note that the serialization of a
// Footer will always occupy exactly this many bytes.  It consists
// of two block handles and a magic number.
const FOOTER_LEN: usize = 48;

// kTableMagicNumber was picked by running
//    echo http://code.google.com/p/leveldb/ | sha1sum
// and taking the leading 64 bits.
const MAGIC: u64 = 0xdb4775248b80fb57_u64;

const MAX_VARINT_LEN64: usize = 10 + 10;

// copy goland binary.Uvarint()
// Uvarint decodes a uint64 from buf and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 meaning:
//
// 	n == 0: buf too small
// 	n  < 0: value larger than 64 bits (overflow)
// 	        and -n is the number of bytes read
//
pub fn get_uvarint(buf: &[u8]) -> std::result::Result<(u64, usize), String> {
    let mut x: u64 = 0;
    let mut s: usize = 0;

    for i in 0..buf.len() {
        if i == MAX_VARINT_LEN64 {
            return Err("overflow".to_string());
            //return (0, -(i as isize + 1)); // overflow
        }

        let b = buf[i];
        if b < 0x80 {
            if i == MAX_VARINT_LEN64 - 1 && b > 1 {
                return Err("overflow".to_string());
                //return (0, -(i as isize + 1)); // overflow
            }
            return Ok((x | (b as u64) << s, i + 1));
        }
        x |= ((b & 0x7f) as u64) << s; //0b0111_1111
        s += 7;
    }
    Err("buf too small".to_string()) //0,0
}

#[cfg(test)]
mod tests {
    use std::io::{Error, ErrorKind, Write};

    use rand::{rngs::ThreadRng, thread_rng, Rng};

    use crate::{
        api::{self, ByteswiseComparator, Comparator, Iterator},
        table::{
            table::{ReadOptions, Table},
            BLOCK_TRAILER_SIZE,
        },
        Options,
    };

    use super::{
        block::{BlockReader, BlockWriter},
        table::{RandomAccessFile, TableWriter},
    };

    type Key = Vec<u8>;
    type Value = Vec<u8>;

    struct KeyValueEntry {
        key: Key,
        value: Value,
    }

    pub struct KeyValue<'a, C: Comparator> {
        entries: Vec<KeyValueEntry>, // entries in ascend order
        n_bytes: usize,

        comparator: &'a C,
    }

    impl<'a, C: Comparator> KeyValue<'a, C> {
        pub fn new(cmp: &'a C) -> Self {
            KeyValue {
                entries: Vec::new(),
                n_bytes: 0,
                comparator: cmp,
            }
        }

        pub fn len(&self) -> usize {
            self.entries.len()
        }

        pub fn size(&self) -> usize {
            self.n_bytes
        }

        pub fn key_at(&self, i: usize) -> Key {
            self.entries[i].key.clone()
        }

        pub fn index_at(&self, i: usize) -> (&Key, &Value) {
            (&self.entries[i].key, &self.entries[i].value)
        }

        pub fn value_at(&self, i: usize) -> Value {
            self.entries[i].value.clone()
        }

        pub fn search(&self, key: &Key) -> Result<usize, usize> {
            self.entries
                .binary_search_by(|entry| self.comparator.compare(&entry.key, &key))
        }

        /* fn get(&self, key:Key) -> Option<usize> {
            self.search(key)
        } */

        pub fn delete_index(&mut self, i: usize) -> Option<Value> {
            if i < self.len() {
                self.n_bytes -= self.key_at(i).len() + self.value_at(i).len();
                return Some(self.entries.remove(i).value);
            }
            None
        }

        pub fn delete(&mut self, key: &Key) -> Option<Value> {
            match self.search(&key) {
                Err(_) => None,
                Ok(i) => self.delete_index(i),
            }
        }

        // insert return true, update return false
        pub fn put_u(&mut self, key: &Key, value: &Value) -> bool {
            match self.search(&key) {
                Ok(i) => {
                    self.n_bytes += value.len() - self.value_at(i).len();
                    self.entries[i].value = value.clone();
                }
                Err(i) => {
                    self.n_bytes += key.len() + value.len();
                    self.entries.insert(
                        i,
                        KeyValueEntry {
                            key: key.clone(),
                            value: value.clone(),
                        },
                    );
                    return true;
                }
            }
            false
        }

        pub fn append(&mut self, key: &Key, value: &Value) {
            let n = self.entries.len();
            if n > 0
                && self
                    .comparator
                    .compare(key, &self.entries[n - 1].key)
                    .is_le()
            {
                panic!("append, keys not in increasing order");
            }
            self.entries.push(KeyValueEntry {
                key: key.clone(),
                value: value.clone(),
            });
            self.n_bytes += key.len() + value.len();
        }

        pub fn clear(&mut self) {
            self.entries.clear();
            self.n_bytes = 0;
        }
    }

    struct BufferSource {
        buf: Vec<u8>,
    }
    impl BufferSource {
        fn new(buf: Vec<u8>) -> Self {
            BufferSource { buf: buf }
        }
    }
    impl RandomAccessFile for BufferSource {
        fn read(&self, offset: usize, n: usize, dst: &mut Vec<u8>) -> std::io::Result<usize> {
            let mut r = n;
            if offset > self.buf.len() {
                return Err(Error::new(ErrorKind::Other, "invalid offset"));
            }
            if offset + n > self.buf.len() {
                r = self.buf.len() - offset;
            }
            dst.write(&self.buf[offset..offset + r])?;
            Ok(r)
        }
    }

    enum TestCase {
        Table,
        Block,
    }

    static INTERVALS: [usize; 3] = [1, 16, 1024];

    #[test]
    fn test_empty() {
        let cmp = ByteswiseComparator::default();
        let kv = KeyValue::new(&cmp);

        test(TestCase::Block, &cmp, &kv);
        test(TestCase::Table, &cmp, &kv);
    }

    #[test]
    fn test_simple_single() {
        let cmp = ByteswiseComparator::default();
        let mut kv = KeyValue::new(&cmp);
        kv.append(&"abc".as_bytes().to_vec(), &"v".as_bytes().to_vec());

        test(TestCase::Block, &cmp, &kv);
        test(TestCase::Table, &cmp, &kv)
    }

    #[test]
    fn test_simple_specical_key() {
        let cmp = ByteswiseComparator::default();
        let mut kv = KeyValue::new(&cmp);
        let key = vec![0xff, 0xff];
        kv.append(&key, &"v3".as_bytes().to_vec());

        test(TestCase::Block, &cmp, &kv);
        test(TestCase::Table, &cmp, &kv)
    }

    #[test]
    fn test_simple_multi() {
        let cmp = ByteswiseComparator::default();
        let mut kv = KeyValue::new(&cmp);
        kv.append(&"abc".as_bytes().to_vec(), &"v".as_bytes().to_vec());
        kv.append(&"abcd".as_bytes().to_vec(), &"v".as_bytes().to_vec());
        kv.append(&"ac".as_bytes().to_vec(), &"v2".as_bytes().to_vec());

        test(TestCase::Block, &cmp, &kv);
        test(TestCase::Table, &cmp, &kv)
    }

    #[test]
    fn test_randomized() {
        let cmp = ByteswiseComparator::default();
        let mut kv = KeyValue::new(&cmp);

        let mut rng = thread_rng();
        let mut num_entries = 0;
        while num_entries < 2000 {
            kv.clear();

            if (num_entries % 10) == 0 {
                println!("num_entries = {}", num_entries);
            }
            for _ in 0..num_entries {
                let k = random_key(&mut rng, skewed(4));
                let v = random_value(&mut rng, 5);
                kv.put_u(&Vec::from(k), &Vec::from(v));
            }

            if num_entries < 50 {
                num_entries += 1
            } else {
                num_entries += 200
            }

            test(TestCase::Block, &cmp, &kv);
            test(TestCase::Table, &cmp, &kv)
        }
    }

    fn test<'a, C: Comparator>(case: TestCase, compartor: &C, kv: &KeyValue<'a, C>) {
        for v in INTERVALS {
            match case {
                TestCase::Table => {
                    let mut opts = Options::new(compartor.clone());
                    opts.block_restart_interval = v;

                    let mut file = Vec::new();
                    let mut size = 0;
                    {
                        let mut writer = TableWriter::new(&mut file, &opts);

                        for i in 0..kv.len() {
                            let (k, v) = kv.index_at(i);

                            let ar = writer.add(k, v);
                            assert!(ar.is_ok());
                        }

                        let fr = writer.finish();
                        assert!(fr.is_ok());

                        size = writer.file_size();
                    }

                    assert_eq!(size, file.len());

                    let source = BufferSource::new(file);
                    let reader = Table::open(opts, &source, size).unwrap();
                    let opt = ReadOptions::default();
                    let mut it = reader.new_iterator(&opt);

                    test_forward_scan(&mut it, kv);
                    test_backward_scan(&mut it, kv);
                    test_random_access(&mut it, &kv);
                }

                TestCase::Block => {
                    let mut w = BlockWriter::new(v);
                    for i in 0..kv.len() {
                        let (k, v) = kv.index_at(i);
                        w.add(k, v);
                    }
                    let mut file = Vec::new();
                    let wr = w.write(&mut file, crate::CompressionType::NoCompression);
                    assert!(wr.is_ok(), "write block error {:?}", wr.unwrap_err());
                    // no trailer
                    file.truncate(file.len() - BLOCK_TRAILER_SIZE);

                    let block = BlockReader::new(file);
                    let mut it = block.iter(compartor.clone());

                    test_forward_scan(&mut it, kv);
                    test_backward_scan(&mut it, kv);
                    test_random_access(&mut it, &kv);
                }
            }
        }
    }

    fn test_forward_scan<'a, C: Comparator, T: Iterator>(it: &mut T, kv: &KeyValue<'a, C>) {
        assert!(!it.valid().unwrap());
        let r = it.seek_to_first();
        assert!(r.is_ok(), "{:?}", r.unwrap_err());
        let mut i = 0;
        while i < kv.len() {
            assert_eq!(
                kv.index_at(i),
                (&Vec::from(it.key()), &Vec::from(it.value()))
            );
            assert!(it.next().is_ok());
            i += 1;
        }
        assert!(!it.valid().unwrap());
    }

    fn test_backward_scan<'a, C: Comparator, T: Iterator>(it: &mut T, kv: &KeyValue<'a, C>) {
        assert!(!it.valid().unwrap());
        let r = it.seek_to_last();
        assert!(r.is_ok(), "{:?}", r.unwrap_err());
        for i in (0..kv.len()).rev() {
            assert_eq!(
                (&Vec::from(it.key()), &Vec::from(it.value())),
                kv.index_at(i)
            );
            assert!(it.prev().is_ok());
        }
    }

    fn test_random_access<'a, C: Comparator, T: Iterator>(it: &mut T, kv: &KeyValue<'a, C>) {
        let mut rng = thread_rng();

        let verbose = true;
        let mut kv_index = 0;

        assert!(!it.valid().unwrap());

        if verbose {
            println!("---");
        }
        for _ in 0..200 {
            let toss: i32 = rng.gen_range(0..5);
            match toss {
                0 => {
                    if it.valid().unwrap() {
                        if verbose {
                            println!("next");
                        }
                        assert!(it.next().is_ok());
                        if kv_index < kv.len() - 1 {
                            kv_index += 1;
                            assert_eq!(
                                (&Vec::from(it.key()), &Vec::from(it.value())),
                                kv.index_at(kv_index)
                            );
                        } else {
                            assert!(!it.valid().unwrap());
                        }
                    }
                }
                1 => {
                    if verbose {
                        println!("seek_to_first");
                    }
                    let r = it.seek_to_first();
                    assert!(r.is_ok(), "seek_to_first error {:?}", r.unwrap_err());
                    if kv.len() != 0 {
                        kv_index = 0;
                        assert_eq!(
                            (&Vec::from(it.key()), &Vec::from(it.value())),
                            kv.index_at(kv_index)
                        );
                    }
                }
                2 => {
                    if kv.len() != 0 {
                        kv_index = rng.gen_range(0..kv.len());
                        let (k, v) = kv.index_at(kv_index);
                        if verbose {
                            println!("seek {:?}", k.clone())
                        }
                        let s = it.seek(&k);
                        assert!(s.is_ok(), "seek err {:?}", s.unwrap_err());
                        assert_eq!((&Vec::from(it.key()), &Vec::from(it.value())), (k, v));
                    }
                }
                3 => {
                    if it.valid().unwrap() {
                        if verbose {
                            println!("prev");
                        }
                        assert!(it.prev().is_ok());
                        if kv_index == 0 {
                            assert!(!it.valid().unwrap());
                        } else {
                            kv_index -= 1;
                            assert_eq!(
                                (&Vec::from(it.key()), &Vec::from(it.value())),
                                kv.index_at(kv_index)
                            );
                        }
                    }
                }
                4 => {
                    if verbose {
                        println!("seek_to_last");
                    }
                    let r = it.seek_to_last();
                    assert!(r.is_ok(), "seek_to_last err {:?}", r.unwrap_err());
                    if kv.len() == 0 {
                        assert!(!it.valid().unwrap());
                    } else {
                        kv_index = kv.len() - 1;
                        assert_eq!(
                            (&Vec::from(it.key()), &Vec::from(it.value())),
                            kv.index_at(kv_index)
                        );
                    }
                }
                _ => {
                    panic!("rng error")
                }
            }
        }
    }

    static test_bytes: [u8; 10] = [0x0, 0x1, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0xf, 0xf];

    fn random_key(rng: &mut ThreadRng, len: usize) -> &[u8] {
        let mut r = Vec::with_capacity(len);
        for _ in 0..len {
            r.push(test_bytes[rng.gen_range(0..10)]);
        }
        &r
    }

    fn random_value(rng: &mut ThreadRng, len: usize) -> &[u8] {
        let mut r = Vec::with_capacity(len);
        for _ in 0..len {
            r.push(test_bytes[rng.gen_range(0..10)]);
        }
        &r
    }

    // Skewed: pick "base" uniformly from range [0,max_log] and then
    // return "base" random bits.  The effect is to pick a number in the
    // range [0,2^max_log-1] with exponential bias towards smaller numbers.
    pub fn skewed(max_log: i64) -> usize {
        let mut rng = thread_rng();
        let r = rng.gen_range(0..max_log + 1);
        rng.gen_range(0..(1 << r))
    }
}
