/*
Table:

Table is consist of one or more data blocks, an optional filter block
a metaindex block, an index block and a table footer. Metaindex block
is a special block used to keep parameters of the table, such as filter
block name and its block handle. Index block is a special block used to
keep record of data blocks offset and length, index block use one as
restart interval. The key used by index block are the last key of preceding
block, shorter separator of adjacent blocks or shorter successor of the
last key of the last block. Filter block is an optional block contains
sequence of filter data generated by a filter generator.

Table data structure:
                                                         + optional
                                                        /
    +--------------+--------------+--------------+------+-------+-----------------+-------------+--------+
    | data block 1 |      ...     | data block n | filter block | metaindex block | index block | footer |
    +--------------+--------------+--------------+--------------+-----------------+-------------+--------+

    Each block followed by a 5-bytes trailer contains compression type and checksum.

Table block trailer:

    +---------------------------+-------------------+
    | compression type (1-byte) | checksum (4-byte) |
    +---------------------------+-------------------+

    The checksum is a CRC-32 computed using Castagnoli's polynomial. Compression
    type also included in the checksum.

Table footer:

      +------------------- 40-bytes -------------------+
     /                                                  \
    +------------------------+--------------------+------+-----------------+
    | metaindex block handle / index block handle / ---- | magic (8-bytes) |
    +------------------------+--------------------+------+-----------------+

    The magic are first 64-bit of SHA-1 sum of "http://code.google.com/p/leveldb/".

NOTE: All fixed-length integer are little-endian.
*/

/*
Block:

Block is consist of one or more key/value entries and a block trailer.
Block entry shares key prefix with its preceding key until a restart
point reached. A block should contains at least one restart point.
First restart point are always zero.

Block data structure:

      + restart point                 + restart point (depends on restart interval)
     /                               /
    +---------------+---------------+---------------+---------------+---------+
    | block entry 1 | block entry 2 |      ...      | block entry n | trailer |
    +---------------+---------------+---------------+---------------+---------+

Key/value entry:

              +---- key len ----+
             /                   \
    +-------+---------+-----------+---------+--------------------+--------------+----------------+
    | shared (varint) | not shared (varint) | value len (varint) | key (varlen) | value (varlen) |
    +-----------------+---------------------+--------------------+--------------+----------------+

    Block entry shares key prefix with its preceding key:
    Conditions:
        restart_interval=2
        entry one  : key=deck,value=v1
        entry two  : key=dock,value=v2
        entry three: key=duck,value=v3
    The entries will be encoded as follow:

      + restart point (offset=0)                                                 + restart point (offset=16)
     /                                                                          /
    +-----+-----+-----+----------+--------+-----+-----+-----+---------+--------+-----+-----+-----+----------+--------+
    |  0  |  4  |  2  |  "deck"  |  "v1"  |  1  |  3  |  2  |  "ock"  |  "v2"  |  0  |  4  |  2  |  "duck"  |  "v3"  |
    +-----+-----+-----+----------+--------+-----+-----+-----+---------+--------+-----+-----+-----+----------+--------+
     \                                   / \                                  / \                                   /
      +----------- entry one -----------+   +----------- entry two ----------+   +---------- entry three ----------+

    The block trailer will contains two restart points:

    +------------+-----------+--------+
    |     0      |    16     |   2    |
    +------------+-----------+---+----+
     \                      /     \
      +-- restart points --+       + restart points length

Block trailer:

      +-- 4-bytes --+
     /               \
    +-----------------+-----------------+-----------------+------------------------------+
    | restart point 1 |       ....      | restart point n | restart points len (4-bytes) |
    +-----------------+-----------------+-----------------+------------------------------+


NOTE: All fixed-length integer are little-endian.
*/

/*
Filter block:

Filter block consist of one or more filter data and a filter block trailer.
The trailer contains filter data offsets, a trailer offset and a 1-byte base Lg.

Filter block data structure:

      + offset 1      + offset 2      + offset n      + trailer offset
     /               /               /               /
    +---------------+---------------+---------------+---------+
    | filter data 1 |      ...      | filter data n | trailer |
    +---------------+---------------+---------------+---------+

Filter block trailer:

      +- 4-bytes -+
     /             \
    +---------------+---------------+---------------+-------------------------------+------------------+
    | data 1 offset |      ....     | data n offset | data-offsets offset (4-bytes) | base Lg (1-byte) |
    +-------------- +---------------+---------------+-------------------------------+------------------+


NOTE: All fixed-length integer are little-endian.
*/

// from google/leveldb
//
// When we store a key, we drop the prefix shared with the previous
// string.  This helps reduce the space requirement significantly.
// Furthermore, once every K keys, we do not apply the prefix
// compression and store the entire key.  We call this a "restart
// point".  The tail end of the block stores the offsets of all of the
// restart points, and can be used to do a binary search when looking
// for a particular key.  Values are stored as-is (without compression)
// immediately following the corresponding key.
//
// An entry for a particular key-value pair has the form:
//     shared_bytes: varint32
//     unshared_bytes: varint32
//     value_length: varint32
//     key_delta: char[unshared_bytes]
//     value: char[value_length]
// shared_bytes == 0 for restart points.
//
// The trailer of the block has the form:
//     restarts: uint32[num_restarts]
//     num_restarts: uint32
// restarts[i] contains the offset within the block of the ith restart point.

mod block;
pub mod table;

// 1-byte type + 32-bit crc
const BLOCK_TRAILER_SIZE: u64 = 5;

const KI_B: u64 = 1024;
const DEFAULT_BLOCK_SIZE: u64 = 4 * KI_B;

// Encoded length of a Footer.  Note that the serialization of a
// Footer will always occupy exactly this many bytes.  It consists
// of two block handles and a magic number.
const FOOTER_LEN: u64 = 48;

// kTableMagicNumber was picked by running
//    echo http://code.google.com/p/leveldb/ | sha1sum
// and taking the leading 64 bits.
const MAGIC: u64 = 0xdb4775248b80fb57_u64;

#[cfg(test)]
mod tests {
    use std::{collections::HashMap, default};

    use rand::{rngs::ThreadRng, thread_rng, Rng};

    use crate::{
        api::{self, ByteswiseComparator, Iterator},
        db::memtable::{InternalKeyComparator, MemTable, MemTableIterator},
        pack_sequence_and_type, parse_internal_key,
        table::table::{ReadOptions, Table},
        util, Options, RandomAccessFile, ValueType, WritableFile, MAX_SEQUENCE_NUMBER,
    };

    use super::{
        block::{Block, BlockBuilder},
        table::TableBuilder,
    };

    type KVMap = HashMap<Vec<u8>, Vec<u8>>;
    struct Constructor {
        case: TestCase,
        options: Options<ByteswiseComparator>,
        data: KVMap,
        table: Option<Table<ByteswiseComparator>>,
        memtable: Option<MemTable<ByteswiseComparator>>,
        block: Option<Block>,
    }

    impl Constructor {
        fn new(options: Options<ByteswiseComparator>, case: TestCase) -> Self {
            Constructor {
                case,
                options,
                data: KVMap::new(),
                table: None,
                memtable: None,
                block: None,
            }
        }

        fn add(&mut self, key: &[u8], value: &[u8]) {
            self.data.insert(Vec::from(key), Vec::from(value));
        }

        fn finish(&mut self) -> api::Result<(Vec<Vec<u8>>, KVMap)> {
            let mut keys: Vec<Vec<u8>> = self.data.keys().cloned().collect();
            keys.sort();
            match self.case {
                TestCase::Table => {
                    self.new_table(&keys)?;
                }
                TestCase::Block => {
                    self.new_block(&keys)?;
                }
                TestCase::MemTable => {
                    self.new_memtable(&keys)?;
                }
            }
            Ok((keys, self.data.clone()))
        }

        fn new_table(&mut self, keys: &[Vec<u8>]) -> api::Result<()> {
            let mut sink = StringSink {
                contents: Vec::new(),
            };
            let file_size: u64;

            {
                let mut builder = TableBuilder::new(&mut sink, &self.options);

                for k in keys {
                    builder.add(k, self.data.get(k).unwrap())?;
                }
                builder.finish()?;
                file_size = builder.file_size();
            }

            assert_eq!(sink.contents.len(), file_size as usize);

            let source = Box::new(StringSource {
                contents: sink.contents,
            });

            let table = Table::open(&self.options, source, file_size)?;
            self.table = Some(table);
            Ok(())
        }

        fn new_block(&mut self, keys: &[Vec<u8>]) -> api::Result<()> {
            let mut contents = Vec::new();
            let mut builder = BlockBuilder::new(self.options.block_restart_interval);
            for k in keys {
                builder.add(k, self.data.get(k).unwrap());
            }
            contents.extend_from_slice(builder.finish());
            self.block = Some(Block::new(contents));
            Ok(())
        }

        fn new_memtable(&mut self, keys: &[Vec<u8>]) -> api::Result<()> {
            let internal_comparator = InternalKeyComparator::new(&self.options.comparator);
            let mut memtable = MemTable::new(internal_comparator);
            let mut seq = 1;
            for k in keys {
                let v = self.data.get(k).unwrap();
                memtable.add(seq, ValueType::TypeValue, k, v);
                seq += 1;
            }
            self.memtable = Some(memtable);
            Ok(())
        }

        fn new_iterator(&mut self) -> Box<dyn api::Iterator + '_> {
            match self.case {
                TestCase::Table => Box::new(
                    self.table
                        .as_ref()
                        .unwrap()
                        .new_iterator(ReadOptions::default()),
                ),
                TestCase::Block => {
                    let block = self.block.as_ref().unwrap().clone();
                    Box::new(block.new_iterator(self.options.comparator.clone()))
                }
                TestCase::MemTable => {
                    // A helper class that converts internal format keys into user keys
                    struct KeyConvertingIterator<'a, C: api::Comparator> {
                        iter: MemTableIterator<'a, C>,
                    }
                    impl<'a, C: api::Comparator> api::Iterator for KeyConvertingIterator<'a, C> {
                        fn key(&self) -> api::Result<&[u8]> {
                            assert!(self.valid().unwrap());
                            match parse_internal_key(self.iter.key().unwrap()) {
                                Ok(pared_key) => {
                                    return Ok(pared_key.0);
                                }
                                Err(e) => {
                                    return Err(api::Error::Other(e.to_string()));
                                }
                            }
                        }
                        fn next(&mut self) -> api::Result<()> {
                            self.iter.next()
                        }
                        fn prev(&mut self) -> api::Result<()> {
                            self.iter.prev()
                        }
                        fn seek(&mut self, key: &[u8]) -> api::Result<()> {
                            let mut internal_key = key.to_vec();
                            util::put_fixed64(
                                &mut internal_key,
                                pack_sequence_and_type(MAX_SEQUENCE_NUMBER, ValueType::TypeValue),
                            );
                            self.iter.seek(&internal_key)
                        }
                        fn seek_to_first(&mut self) -> api::Result<()> {
                            self.iter.seek_to_first()
                        }
                        fn seek_to_last(&mut self) -> api::Result<()> {
                            self.iter.seek_to_last()
                        }
                        fn valid(&self) -> api::Result<bool> {
                            self.iter.valid()
                        }
                        fn value(&self) -> api::Result<&[u8]> {
                            self.iter.value()
                        }
                    }

                    let memtable = self.memtable.as_mut().unwrap();
                    Box::new(KeyConvertingIterator {
                        iter: memtable.new_iterator(),
                    })
                }
            }
        }
    }

    struct StringSink {
        contents: Vec<u8>,
    }
    impl WritableFile for StringSink {
        fn append(&mut self, data: &[u8]) -> api::Result<()> {
            self.contents.extend_from_slice(data);
            Ok(())
        }
        fn close(&mut self) -> api::Result<()> {
            Ok(())
        }
        fn flush(&mut self) -> api::Result<()> {
            Ok(())
        }
        fn sync(&mut self) -> api::Result<()> {
            Ok(())
        }
    }

    struct StringSource {
        contents: Vec<u8>,
    }

    impl RandomAccessFile for StringSource {
        fn read(&self, offset: u64, n: u64, dst: &mut Vec<u8>) -> api::Result<u64> {
            let mut nn = n;
            if offset >= self.contents.len() as u64 {
                return Err(api::Error::InvalidArgument(format!(
                    "invalid read offset {}, contents {}",
                    offset,
                    self.contents.len()
                )));
            }
            if offset + n > self.contents.len() as u64 {
                nn = self.contents.len() as u64 - offset;
            }
            dst.extend_from_slice(&self.contents[offset as usize..(offset + n) as usize]);
            Ok(nn)
        }
    }

    enum TestCase {
        Table,
        Block,
        MemTable,
    }

    fn init() -> [(TestCase, usize); 6] {
        [
            (TestCase::Table, 16),
            (TestCase::Table, 1024),
            (TestCase::Block, 1),
            (TestCase::Block, 16),
            (TestCase::Block, 1024),
            // Restart interval does not matter for memtables
            (TestCase::MemTable, 1),
            // Do not bother with restart interval variations for DB
        ]
    }

    #[test]
    fn test_empty() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(Options::default(), arg.0);
            test(&mut cons);
        }
    }

    #[test]
    fn test_simple_single() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(Options::default(), arg.0);
            cons.add("abc".as_bytes(), "v".as_bytes());

            test(&mut cons);
        }
    }

    #[test]
    fn test_simple_specical_key() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(Options::default(), arg.0);
            let key = vec![0xff, 0xff];
            cons.add(&key, "v3".as_bytes());

            test(&mut cons);
        }
    }

    #[test]
    fn test_simple_multi() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(Options::default(), arg.0);
            cons.add("abc".as_bytes(), "v".as_bytes());
            cons.add("abcd".as_bytes(), "v".as_bytes());
            cons.add("ac".as_bytes(), "v2".as_bytes());

            test(&mut cons);
        }
    }

    #[test]
    fn test_randomized() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(Options::default(), arg.0);
            let mut rng = thread_rng();
            let mut rnd = util::Random::new(rng.gen::<u32>() + 5);
            let mut num_entries = 0;
            while num_entries < 2000 {
                if (num_entries % 10) == 0 {
                    println!("num_entries = {}", num_entries);
                }
                for _ in 0..num_entries {
                    let k = random_key(&mut rng, rnd.skewed(4) as usize);
                    let v = random_value(&mut rng, rnd.skewed(5) as usize);
                    cons.add(&k, &v);
                }

                if num_entries < 50 {
                    num_entries += 1
                } else {
                    num_entries += 200
                }

                test(&mut cons);
            }
        }
    }

    fn test(constructor: &mut Constructor) {
        let (keys, kvmap) = constructor.finish().unwrap();

        {
            let mut it = constructor.new_iterator();
            test_forward_scan(it.as_mut(), &keys, &kvmap);
        }

        {
            let mut it = constructor.new_iterator();
            test_backward_scan(it.as_mut(), &keys, &kvmap);
        }

        {
            let mut it = constructor.new_iterator();
            test_random_access(it.as_mut(), &keys, &kvmap);
        }
    }

    fn test_forward_scan(it: &mut dyn Iterator, keys: &[Vec<u8>], kvmap: &KVMap) {
        assert!(!it.valid().unwrap());
        let r = it.seek_to_first();
        assert!(r.is_ok(), "{:?}", r.unwrap_err());

        for key in keys.iter() {
            assert_eq!(it.key().unwrap(), key);
            assert_eq!(it.value().unwrap(), kvmap.get(key).unwrap());
            assert!(it.next().is_ok());
        }
        assert!(!it.valid().unwrap());
    }

    fn test_backward_scan(it: &mut dyn api::Iterator, keys: &[Vec<u8>], kvmap: &KVMap) {
        assert!(!it.valid().unwrap());
        let r = it.seek_to_last();
        assert!(r.is_ok(), "{:?}", r.unwrap_err());

        for i in (0..keys.len()).rev() {
            assert_eq!(it.key().unwrap(), keys[i]);
            assert_eq!(it.value().unwrap(), kvmap.get(&keys[i]).unwrap());
            assert!(it.prev().is_ok());
        }
    }

    fn test_random_access(it: &mut dyn Iterator, keys: &[Vec<u8>], kvmap: &KVMap) {
        let mut rng = thread_rng();

        let verbose = true;
        let mut key_index = 0;

        assert!(!it.valid().unwrap());

        if verbose {
            println!("---");
        }
        for _ in 0..200 {
            let toss: i32 = rng.gen_range(0..5);
            match toss {
                0 => {
                    if it.valid().unwrap() {
                        if verbose {
                            println!("next");
                        }
                        assert!(it.next().is_ok());
                        if key_index < keys.len() - 1 {
                            key_index += 1;
                            assert_eq!(it.key().unwrap(), keys[key_index]);
                            assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                        } else {
                            assert!(!it.valid().unwrap());
                        }
                    }
                }
                1 => {
                    if verbose {
                        println!("seek_to_first");
                    }
                    let r = it.seek_to_first();
                    assert!(r.is_ok(), "seek_to_first error {:?}", r.unwrap_err());
                    if keys.len() != 0 {
                        key_index = 0;
                        assert_eq!(it.key().unwrap(), keys[key_index]);
                        assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                    } else {
                        assert!(!it.valid().unwrap());
                    }
                }
                2 => {
                    if keys.len() != 0 {
                        key_index = rng.gen_range(0..keys.len());
                        let k = &keys[key_index];
                        if verbose {
                            println!("seek {:?}", k.clone())
                        }
                        let s = it.seek(&k);
                        assert!(s.is_ok(), "seek err {:?}", s.unwrap_err());
                        assert_eq!(it.key().unwrap(), k);
                        assert_eq!(it.value().unwrap(), kvmap.get(k).unwrap());
                    } else {
                        assert!(!it.valid().unwrap());
                    }
                }
                3 => {
                    if it.valid().unwrap() {
                        if verbose {
                            println!("prev");
                        }
                        assert!(it.prev().is_ok());
                        if key_index == 0 {
                            assert!(!it.valid().unwrap());
                        } else {
                            key_index -= 1;
                            assert_eq!(it.key().unwrap(), keys[key_index]);
                            assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                        }
                    }
                }
                4 => {
                    if verbose {
                        println!("seek_to_last");
                    }
                    let r = it.seek_to_last();
                    assert!(r.is_ok(), "seek_to_last err {:?}", r.unwrap_err());
                    if keys.len() == 0 {
                        assert!(!it.valid().unwrap());
                    } else {
                        key_index = keys.len() - 1;
                        assert_eq!(it.key().unwrap(), keys[key_index]);
                        assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                    }
                }
                _ => {
                    panic!("rng error")
                }
            }
        }
    }

    static TEST_BYTES: [u8; 10] = [0x0, 0x1, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0xf, 0xf];

    fn random_key(rng: &mut ThreadRng, len: usize) -> Vec<u8> {
        let mut r = Vec::with_capacity(len);
        for _ in 0..len {
            r.push(TEST_BYTES[rng.gen_range(0..10)]);
        }
        r
    }

    fn random_value(rng: &mut ThreadRng, len: usize) -> Vec<u8> {
        let mut r = Vec::with_capacity(len);
        for _ in 0..len {
            r.push(TEST_BYTES[rng.gen_range(0..10)]);
        }
        r
    }
}
