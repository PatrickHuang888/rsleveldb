/*
Table:

Table is consist of one or more data blocks, an optional filter block
a metaindex block, an index block and a table footer. Metaindex block
is a special block used to keep parameters of the table, such as filter
block name and its block handle. Index block is a special block used to
keep record of data blocks offset and length, index block use one as
restart interval. The key used by index block are the last key of preceding
block, shorter separator of adjacent blocks or shorter successor of the
last key of the last block. Filter block is an optional block contains
sequence of filter data generated by a filter generator.

Table data structure:
                                                         + optional
                                                        /
    +--------------+--------------+--------------+------+-------+-----------------+-------------+--------+
    | data block 1 |      ...     | data block n | filter block | metaindex block | index block | footer |
    +--------------+--------------+--------------+--------------+-----------------+-------------+--------+

    Each block followed by a 5-bytes trailer contains compression type and checksum.

Table block trailer:

    +---------------------------+-------------------+
    | compression type (1-byte) | checksum (4-byte) |
    +---------------------------+-------------------+

    The checksum is a CRC-32 computed using Castagnoli's polynomial. Compression
    type also included in the checksum.

Table footer:

      +------------------- 40-bytes -------------------+
     /                                                  \
    +------------------------+--------------------+------+-----------------+
    | metaindex block handle / index block handle / ---- | magic (8-bytes) |
    +------------------------+--------------------+------+-----------------+

    The magic are first 64-bit of SHA-1 sum of "http://code.google.com/p/leveldb/".

NOTE: All fixed-length integer are little-endian.
*/

/*
Block:

Block is consist of one or more key/value entries and a block trailer.
Block entry shares key prefix with its preceding key until a restart
point reached. A block should contains at least one restart point.
First restart point are always zero.

Block data structure:

      + restart point                 + restart point (depends on restart interval)
     /                               /
    +---------------+---------------+---------------+---------------+---------+
    | block entry 1 | block entry 2 |      ...      | block entry n | trailer |
    +---------------+---------------+---------------+---------------+---------+

Key/value entry:

              +---- key len ----+
             /                   \
    +-------+---------+-----------+---------+--------------------+--------------+----------------+
    | shared (varint) | not shared (varint) | value len (varint) | key (varlen) | value (varlen) |
    +-----------------+---------------------+--------------------+--------------+----------------+

    Block entry shares key prefix with its preceding key:
    Conditions:
        restart_interval=2
        entry one  : key=deck,value=v1
        entry two  : key=dock,value=v2
        entry three: key=duck,value=v3
    The entries will be encoded as follow:

      + restart point (offset=0)                                                 + restart point (offset=16)
     /                                                                          /
    +-----+-----+-----+----------+--------+-----+-----+-----+---------+--------+-----+-----+-----+----------+--------+
    |  0  |  4  |  2  |  "deck"  |  "v1"  |  1  |  3  |  2  |  "ock"  |  "v2"  |  0  |  4  |  2  |  "duck"  |  "v3"  |
    +-----+-----+-----+----------+--------+-----+-----+-----+---------+--------+-----+-----+-----+----------+--------+
     \                                   / \                                  / \                                   /
      +----------- entry one -----------+   +----------- entry two ----------+   +---------- entry three ----------+

    The block trailer will contains two restart points:

    +------------+-----------+--------+
    |     0      |    16     |   2    |
    +------------+-----------+---+----+
     \                      /     \
      +-- restart points --+       + restart points length

Block trailer:

      +-- 4-bytes --+
     /               \
    +-----------------+-----------------+-----------------+------------------------------+
    | restart point 1 |       ....      | restart point n | restart points len (4-bytes) |
    +-----------------+-----------------+-----------------+------------------------------+


NOTE: All fixed-length integer are little-endian.
*/

/*
Filter block:

Filter block consist of one or more filter data and a filter block trailer.
The trailer contains filter data offsets, a trailer offset and a 1-byte base Lg.

Filter block data structure:

      + offset 1      + offset 2      + offset n      + trailer offset
     /               /               /               /
    +---------------+---------------+---------------+---------+
    | filter data 1 |      ...      | filter data n | trailer |
    +---------------+---------------+---------------+---------+

Filter block trailer:

      +- 4-bytes -+
     /             \
    +---------------+---------------+---------------+-------------------------------+------------------+
    | data 1 offset |      ....     | data n offset | data-offsets offset (4-bytes) | base Lg (1-byte) |
    +-------------- +---------------+---------------+-------------------------------+------------------+


NOTE: All fixed-length integer are little-endian.
*/

// from google/leveldb
//
// When we store a key, we drop the prefix shared with the previous
// string.  This helps reduce the space requirement significantly.
// Furthermore, once every K keys, we do not apply the prefix
// compression and store the entire key.  We call this a "restart
// point".  The tail end of the block stores the offsets of all of the
// restart points, and can be used to do a binary search when looking
// for a particular key.  Values are stored as-is (without compression)
// immediately following the corresponding key.
//
// An entry for a particular key-value pair has the form:
//     shared_bytes: varint32
//     unshared_bytes: varint32
//     value_length: varint32
//     key_delta: char[unshared_bytes]
//     value: char[value_length]
// shared_bytes == 0 for restart points.
//
// The trailer of the block has the form:
//     restarts: uint32[num_restarts]
//     num_restarts: uint32
// restarts[i] contains the offset within the block of the ith restart point.

mod block;
mod table;

// 1-byte type + 32-bit crc
const BLOCK_TRAILER_SIZE: usize = 5;

const KI_B: usize = 1024;
const DEFAULT_BLOCK_SIZE: usize = 4 * KI_B;

// Encoded length of a Footer.  Note that the serialization of a
// Footer will always occupy exactly this many bytes.  It consists
// of two block handles and a magic number.
const FOOTER_LEN: usize = 48;

// kTableMagicNumber was picked by running
//    echo http://code.google.com/p/leveldb/ | sha1sum
// and taking the leading 64 bits.
const MAGIC: u64 = 0xdb4775248b80fb57_u64;

const MAX_VARINT_LEN64: usize = 10 + 10;

// copy goland binary.Uvarint()
// Uvarint decodes a uint64 from buf and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 meaning:
//
// 	n == 0: buf too small
// 	n  < 0: value larger than 64 bits (overflow)
// 	        and -n is the number of bytes read
//
pub fn get_uvarint(buf: &[u8]) -> std::result::Result<(u64, usize), String> {
    let mut x: u64 = 0;
    let mut s: usize = 0;

    for i in 0..buf.len() {
        if i == MAX_VARINT_LEN64 {
            return Err("overflow".to_string());
            //return (0, -(i as isize + 1)); // overflow
        }

        let b = buf[i];
        if b < 0x80 {
            if i == MAX_VARINT_LEN64 - 1 && b > 1 {
                return Err("overflow".to_string());
                //return (0, -(i as isize + 1)); // overflow
            }
            return Ok((x | (b as u64) << s, i + 1));
        }
        x |= ((b & 0x7f) as u64) << s; //0b0111_1111
        s += 7;
    }
    Err("buf too small".to_string()) //0,0
}

#[cfg(test)]
mod tests {
    use std::{collections::HashMap, rc::Rc};

    use rand::{rngs::ThreadRng, thread_rng, Rng};

    use crate::{
        api::{self, Iterator},
        db::{
            self,
            memtable::{self, InternalKeyComparator, MemTable, MemTableIterator},
            ValueType,
        },
        table::table::{ReadOptions, Table},
        util, Options, WritableFile, RandomAccessFile,
    };

    use super::{
        block::{Block, BlockBuilder, BlockIterator},
        table::TableBuilder,
    };

    type KVMap = HashMap<Vec<u8>, Vec<u8>>;
    struct Constructor {
        options: Options,
        data: KVMap,
        cons_impl: Box<dyn ConstructorImpl>,
    }

    trait ConstructorImpl {
        fn finish(
            &mut self,
            options: &Options,
            keys: &Vec<Vec<u8>>,
            kvmap: &KVMap,
        ) -> api::Result<()>;

        fn iter(&mut self) -> Box<dyn api::Iterator + '_>;
    }

    struct TableCons {
        table: Option<Table>,
    }

    impl ConstructorImpl for TableCons {
        fn finish(
            &mut self,
            options: &Options,
            keys: &Vec<Vec<u8>>,
            kvmap: &KVMap,
        ) -> api::Result<()> {
            let mut sink = StringSink {
                contents: Vec::new(),
            };
            let file_size: usize;

            {
                let mut builder = TableBuilder::new(&mut sink, options.clone());

                for k in keys {
                    builder.add(k, kvmap.get(k).unwrap())?;
                }
                builder.finish()?;
                file_size = builder.file_size();
            }

            assert_eq!(sink.contents.len(), file_size);

            let source = Rc::new(StringSource {
                contents: sink.contents,
            });

            let table = Table::open(options.clone(), source, file_size)?;
            self.table = Some(table);

            Ok(())
        }

        fn iter(&mut self) -> Box<dyn api::Iterator + '_> {
            let table = self.table.as_ref().unwrap();
            Box::new(table.iter(ReadOptions::default()))
        }
    }

    struct BlockCons {
        block_iter: Option<BlockIterator>,
    }

    impl ConstructorImpl for BlockCons {
        fn finish(
            &mut self,
            options: &Options,
            keys: &Vec<Vec<u8>>,
            kvmap: &KVMap,
        ) -> api::Result<()> {
            let mut contents = Vec::new();
            let mut builder = BlockBuilder::new(options.block_restart_interval);
            for k in keys {
                builder.add(k, kvmap.get(k).unwrap());
            }
            contents.extend_from_slice(builder.finish());

            let block = Block::new(contents);
            self.block_iter = Some(block.new_iter(options.comparator.clone()));
            Ok(())
        }

        fn iter(&mut self) -> Box<dyn api::Iterator + '_> {
            let iter = self.block_iter.as_ref().unwrap().clone();
            Box::new(iter)
        }
    }

    struct MemTableCons {
        table: Option<memtable::MemTable>,
    }

    impl ConstructorImpl for MemTableCons {
        fn finish(
            &mut self,
            options: &Options,
            keys: &Vec<Vec<u8>>,
            kvmap: &KVMap,
        ) -> api::Result<()> {
            let internal_comparator = InternalKeyComparator::new(options.comparator.clone());
            let mut memtable = MemTable::new(internal_comparator);
            let mut seq = 1;
            for k in keys {
                let v = kvmap.get(k).unwrap();
                memtable.add(seq, ValueType::TypeValue, k, v);
                seq += 1;
            }
            self.table = Some(memtable);
            Ok(())
        }

        fn iter(&mut self) -> Box<dyn api::Iterator + '_> {
            // A helper class that converts internal format keys into user keys
            struct KeyConvertingIterator<'a> {
                iter: MemTableIterator<'a>,
            }
            impl<'a> api::Iterator for KeyConvertingIterator<'a> {
                fn key(&self) -> api::Result<&[u8]> {
                    assert!(self.valid().unwrap());
                    match db::parse_internal_key(self.iter.key().unwrap()) {
                        Ok(pared_key) => {
                            return Ok(pared_key.0);
                        }
                        Err(e) => {
                            return Err(api::Error::Other(e.to_string()));
                        }
                    }
                }
                fn next(&mut self) -> api::Result<()> {
                    self.iter.next()
                }
                fn prev(&mut self) -> api::Result<()> {
                    self.iter.prev()
                }
                fn seek(&mut self, key: &[u8]) -> api::Result<()> {
                    let mut internal_key = key.to_vec();
                    util::put_fixed64(
                        &mut internal_key,
                        db::pack_sequence_and_type(db::MAX_SEQUENCE_NUMBER, ValueType::TypeValue),
                    );
                    self.iter.seek(&internal_key)
                }
                fn seek_to_first(&mut self) -> api::Result<()> {
                    self.iter.seek_to_first()
                }
                fn seek_to_last(&mut self) -> api::Result<()> {
                    self.iter.seek_to_last()
                }
                fn valid(&self) -> api::Result<bool> {
                    self.iter.valid()
                }
                fn value(&self) -> api::Result<&[u8]> {
                    self.iter.value()
                }
            }

            Box::new(KeyConvertingIterator {
                iter: self.table.as_mut().unwrap().new_iter(),
            })
        }
    }

    struct StringSink {
        contents: Vec<u8>,
    }
    impl WritableFile for StringSink {
        fn append(&mut self, data: &[u8]) -> api::Result<()> {
            self.contents.extend_from_slice(data);
            Ok(())
        }
        fn close(&mut self) -> api::Result<()> {
            Ok(())
        }
        fn flush(&mut self) -> api::Result<()> {
            Ok(())
        }
        fn sync(&mut self) -> api::Result<()> {
            Ok(())
        }
    }

    struct StringSource {
        contents: Vec<u8>,
    }

    impl RandomAccessFile for StringSource {
        fn read(&self, offset: usize, n: usize, dst: &mut Vec<u8>) -> api::Result<usize> {
            let mut nn = n;
            if offset >= self.contents.len() {
                return Err(api::Error::InvalidArgument(format!(
                    "invalid read offset {}, contents {}",
                    offset,
                    self.contents.len()
                )));
            }
            if offset + n > self.contents.len() {
                nn = self.contents.len() - offset;
            }
            dst.extend_from_slice(&self.contents[offset..offset + n]);
            Ok(nn)
        }
    }

    // Helper class for tests to unify the interface between
    // BlockBuilder/TableBuilder and Block/Table.
    impl Constructor {
        fn new(arg: (TestCase, usize)) -> Self {
            let mut options = Options::default();
            options.block_restart_interval = arg.1;

            match arg.0 {
                TestCase::Table => {
                    return Constructor {
                        options,
                        data: HashMap::new(),
                        cons_impl: Box::new(TableCons { table: None }),
                    }
                }
                TestCase::Block => {
                    return Constructor {
                        options,
                        data: HashMap::new(),
                        cons_impl: Box::new(BlockCons { block_iter: None }),
                    };
                }
                TestCase::MemTable => {
                    return Constructor {
                        options,
                        data: HashMap::new(),
                        cons_impl: Box::new(MemTableCons { table: None }),
                    };
                }
            }
        }

        fn add(&mut self, key: &[u8], value: &[u8]) {
            self.data.insert(Vec::from(key), Vec::from(value));
        }

        // Finish constructing the data structure with all the keys that have
        // been added so far.  Returns the keys in sorted order in "*keys"
        // and stores the key/value pairs in "*kvmap"
        fn finish(&mut self) -> (Vec<Vec<u8>>, KVMap) {
            let mut keys: Vec<Vec<u8>> = self.data.keys().cloned().collect();
            keys.sort();

            let s = self.cons_impl.finish(&self.options, &keys, &self.data);
            assert!(s.is_ok(), "{:?}", s);

            (keys, self.data.clone())
        }
    }

    enum TestCase {
        Table,
        Block,
        MemTable,
    }

    fn init() -> [(TestCase, usize); 6] {
        [
            (TestCase::Table, 16),
            (TestCase::Table, 1024),
            (TestCase::Block, 1),
            (TestCase::Block, 16),
            (TestCase::Block, 1024),
            // Restart interval does not matter for memtables
            (TestCase::MemTable, 1),
            // Do not bother with restart interval variations for DB
        ]
    }

    #[test]
    fn test_empty() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(arg);

            test(&mut cons);
        }
    }

    #[test]
    fn test_simple_single() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(arg);
            cons.add("abc".as_bytes(), "v".as_bytes());

            test(&mut cons);
        }
    }

    #[test]
    fn test_simple_specical_key() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(arg);
            let key = vec![0xff, 0xff];
            cons.add(&key, "v3".as_bytes());

            test(&mut cons);
        }
    }

    #[test]
    fn test_simple_multi() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(arg);
            cons.add("abc".as_bytes(), "v".as_bytes());
            cons.add("abcd".as_bytes(), "v".as_bytes());
            cons.add("ac".as_bytes(), "v2".as_bytes());

            test(&mut cons);
        }
    }

    #[test]
    fn test_randomized() {
        let test_args = init();
        for arg in test_args {
            let mut cons = Constructor::new(arg);
            let mut rng = thread_rng();
            let mut rnd= util::Random::new(rng.gen::<u32>()+5);
            let mut num_entries = 0;
            while num_entries < 2000 {
                if (num_entries % 10) == 0 {
                    println!("num_entries = {}", num_entries);
                }
                for _ in 0..num_entries {
                    let k = random_key(&mut rng, rnd.skewed(4) as usize);
                    let v = random_value(&mut rng, rnd.skewed(5) as usize);
                    cons.add(&k, &v);
                }

                if num_entries < 50 {
                    num_entries += 1
                } else {
                    num_entries += 200
                }

                test(&mut cons);
            }
        }
    }

    fn test(constructor: &mut Constructor) {
        let (keys, kvmap) = constructor.finish();
        {
            let mut it = constructor.cons_impl.iter();
            test_forward_scan(&mut it, &keys, &kvmap);
        }
        {
            let mut it = constructor.cons_impl.iter();
            test_backward_scan(&mut it, &keys, &kvmap);
        }
        {
            let it = constructor.cons_impl.iter();
            test_random_access(it, &keys, &kvmap);
        }
    }

    fn test_forward_scan(it: &mut Box<dyn Iterator + '_>, keys: &Vec<Vec<u8>>, kvmap: &KVMap) {
        assert!(!it.valid().unwrap());
        let r = it.seek_to_first();
        assert!(r.is_ok(), "{:?}", r.unwrap_err());

        for key in keys.iter() {
            assert_eq!(it.key().unwrap(), key);
            assert_eq!(it.value().unwrap(), kvmap.get(key).unwrap());
            assert!(it.next().is_ok());
        }
        assert!(!it.valid().unwrap());
    }

    fn test_backward_scan(mut it: &mut Box<dyn Iterator + '_>, keys: &Vec<Vec<u8>>, kvmap: &KVMap) {
        assert!(!it.valid().unwrap());
        let r = it.seek_to_last();
        assert!(r.is_ok(), "{:?}", r.unwrap_err());

        for i in (0..keys.len()).rev() {
            assert_eq!(it.key().unwrap(), keys[i]);
            assert_eq!(it.value().unwrap(), kvmap.get(&keys[i]).unwrap());
            assert!(it.prev().is_ok());
        }
    }

    fn test_random_access(mut it: Box<dyn Iterator + '_>, keys: &Vec<Vec<u8>>, kvmap: &KVMap) {
        let mut rng = thread_rng();

        let verbose = true;
        let mut key_index = 0;

        assert!(!it.valid().unwrap());

        if verbose {
            println!("---");
        }
        for _ in 0..200 {
            let toss: i32 = rng.gen_range(0..5);
            match toss {
                0 => {
                    if it.valid().unwrap() {
                        if verbose {
                            println!("next");
                        }
                        assert!(it.next().is_ok());
                        if key_index < keys.len() - 1 {
                            key_index += 1;
                            assert_eq!(it.key().unwrap(), keys[key_index]);
                            assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                        } else {
                            assert!(!it.valid().unwrap());
                        }
                    }
                }
                1 => {
                    if verbose {
                        println!("seek_to_first");
                    }
                    let r = it.seek_to_first();
                    assert!(r.is_ok(), "seek_to_first error {:?}", r.unwrap_err());
                    if keys.len() != 0 {
                        key_index = 0;
                        assert_eq!(it.key().unwrap(), keys[key_index]);
                        assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                    } else {
                        assert!(!it.valid().unwrap());
                    }
                }
                2 => {
                    if keys.len() != 0 {
                        key_index = rng.gen_range(0..keys.len());
                        let k = &keys[key_index];
                        if verbose {
                            println!("seek {:?}", k.clone())
                        }
                        let s = it.seek(&k);
                        assert!(s.is_ok(), "seek err {:?}", s.unwrap_err());
                        assert_eq!(it.key().unwrap(), k);
                        assert_eq!(it.value().unwrap(), kvmap.get(k).unwrap());
                    } else {
                        assert!(!it.valid().unwrap());
                    }
                }
                3 => {
                    if it.valid().unwrap() {
                        if verbose {
                            println!("prev");
                        }
                        assert!(it.prev().is_ok());
                        if key_index == 0 {
                            assert!(!it.valid().unwrap());
                        } else {
                            key_index -= 1;
                            assert_eq!(it.key().unwrap(), keys[key_index]);
                            assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                        }
                    }
                }
                4 => {
                    if verbose {
                        println!("seek_to_last");
                    }
                    let r = it.seek_to_last();
                    assert!(r.is_ok(), "seek_to_last err {:?}", r.unwrap_err());
                    if keys.len() == 0 {
                        assert!(!it.valid().unwrap());
                    } else {
                        key_index = keys.len() - 1;
                        assert_eq!(it.key().unwrap(), keys[key_index]);
                        assert_eq!(it.value().unwrap(), kvmap.get(&keys[key_index]).unwrap());
                    }
                }
                _ => {
                    panic!("rng error")
                }
            }
        }
    }

    static TEST_BYTES: [u8; 10] = [0x0, 0x1, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0xf, 0xf];

    fn random_key(rng: &mut ThreadRng, len: usize) -> Vec<u8> {
        let mut r = Vec::with_capacity(len);
        for _ in 0..len {
            r.push(TEST_BYTES[rng.gen_range(0..10)]);
        }
        r
    }

    fn random_value(rng: &mut ThreadRng, len: usize) -> Vec<u8> {
        let mut r = Vec::with_capacity(len);
        for _ in 0..len {
            r.push(TEST_BYTES[rng.gen_range(0..10)]);
        }
        r
    }

    
}
